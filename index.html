<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>CarbonicSoda | Hilbert Curve Sort Demo</title>
		<style>
			* {
				box-sizing: border-box;
			}

			.flex {
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.col {
				flex-direction: column;
			}

			section {
				border-top: 3px black solid;
				width: 100vw;
				padding-bottom: 20px;
			}
			textarea {
				width: 15vw;
				height: 15vw;
				font-size: 1.7vw;
				resize: none;
			}
			input {
				width: 10vw;
				height: 3vw;
				font-size: 1.5vw;
			}
			button {
				width: 10vw;
				height: 5vw;
				margin: 10px;
				font-size: 1.7vw;
			}

			#pts2d-demo canvas {
				background-color: whitesmoke;
				border: 3px lightgrey solid;
				margin-right: 4vw;
			}
			#colors-canvases {
				margin-bottom: 20px;
			}
			#colors-actions p {
				width: 10vw;
			}
		</style>
	</head>

	<body>
		<main class="flex col">
			<h1>Hilbert Curve Sort Demos</h1>
			<br />
			<section id="pts2d" class="flex col">
				<h2>2D Points</h2>
				<div id="pts2d-demo" class="flex">
					<canvas>sorted 2d points connected in order</canvas>
					<div id="pts2d-actions" class="flex col">
						<textarea></textarea>
						<button id="pts2d-set">Set</button>
						<br />
						<br />
						<input type="number" placeholder="Num Points" />
						<button id="pts2d-random">Random</button>
					</div>
				</div>
			</section>
			<br />
			<section id="colors" class="flex col">
				<h2>Colors (sRGB)</h2>
				<div id="colors-demo" class="flex col">
					<div id="colors-canvases" class="flex col">
						<canvas id="colors-original">original color ordering</canvas>
						<br />
						<canvas id="colors-sorted">sorted color ordering</canvas>
					</div>
					<div id="colors-actions" class="flex">
						<textarea></textarea>
						<button id="colors-set">Set</button>
						<p></p>
						<input type="number" placeholder="Num Colors" />
						<button id="colors-random">Random</button>
					</div>
				</div>
			</section>
		</main>
		<script type="module">
			import { h2CurveSort, h3CurveSort } from "./hilbert-curve-sort.js";

			const rand = (a, b) => Math.random() * (b - a) + a;

			const pageWidth = window.innerWidth;
			const pageHeight = window.innerHeight;

			// 2D Points Section
			const pts2dCvs = document.querySelector("#pts2d-demo canvas");
			const pts2dPts = document.querySelector("#pts2d-actions textarea");
			const pts2dSet = document.querySelector("#pts2d-set");
			const pts2dRdmN = document.querySelector("#pts2d-actions input");
			const pts2dRdm = document.querySelector("#pts2d-random");

			const pts2dCtx = pts2dCvs.getContext("2d");
			const pts2dSide = pageWidth * 0.45;
			pts2dCvs.setAttribute("width", pts2dSide);
			pts2dCvs.setAttribute("height", pts2dSide);

			async function draw2dPts(pts) {
				pts2dCtx.clearRect(0, 0, pts2dSide, pts2dSide);

				const sorted = await h2CurveSort(pts);
				pts2dCtx.moveTo(sorted[0][0], pts2dSide - sorted[0][1]);
				pts2dCtx.beginPath();
				for (let [x, y] of sorted) {
					y = pts2dSide - y;
					if (sorted.length <= 500) pts2dCtx.fillRect(x - 4, y - 4, 8, 8);
					pts2dCtx.lineTo(x, y);
				}
				pts2dCtx.moveTo(sorted[0][0], pts2dSide - sorted[0][1]);
				pts2dCtx.closePath();
				pts2dCtx.stroke();
			}

			function drawSetPts(_pts) {
				const pts = (_pts ?? pts2dPts.value)
					.trim()
					.split("\n")
					.map((coords) => coords.split(" ").map(Number))
					.filter((vec) => vec.length === 2 && vec.every(Number.isFinite));
				if (pts.length < 2) {
					drawSetPts(pts2dPts.getAttribute("placeholder"));
					return;
				}
				let [minX, minY] = pts[0];
				let [maxX, maxY] = pts[0];
				for (const [x, y] of pts) {
					if (x < minX) minX = x;
					else if (x > maxX) maxX = x;
					if (y < minY) minY = y;
					else if (y > maxY) maxY = y;
				}
				let scaleX = (pts2dSide - 40) / (maxX - minX);
				let scaleY = (pts2dSide - 40) / (maxY - minY);
				if (scaleX === 0 || !Number.isFinite(scaleX)) scaleX = 1;
				if (scaleY === 0 || !Number.isFinite(scaleY)) scaleY = 1;
				draw2dPts(pts.map(([x, y]) => [scaleX * (x - minX) + 20, scaleY * (y - minY) + 20]));
			}
			pts2dSet.addEventListener("click", () => drawSetPts());
			pts2dRdm.addEventListener("click", () => {
				let n = Number(pts2dRdmN.value);
				if (!n) n = 100;
				const pts = [...Array(n)].map(() => [rand(0, pts2dSide), rand(0, pts2dSide)]);
				draw2dPts(pts);
			});

			pts2dPts.setAttribute("placeholder", "0 0\n0 1\n1 0\n1 1");
			drawSetPts();

			// Colors (sRGB) Section
			const clrsOriginalCvs = document.querySelector("#colors-original");
			const clrsSortedCvs = document.querySelector("#colors-sorted");
			const clrsInput = document.querySelector("#colors-actions textarea");
			const clrsSet = document.querySelector("#colors-set");
			const clrsRdmN = document.querySelector("#colors-actions input");
			const clrsRdm = document.querySelector("#colors-random");

			const clrsOriginalCtx = clrsOriginalCvs.getContext("2d");
			const clrsSortedCtx = clrsSortedCvs.getContext("2d");
			const clrsCvsWidth = pageWidth * 0.9;
			const clrsCvsHeight = pageHeight * 0.1;
			clrsOriginalCvs.setAttribute("width", clrsCvsWidth);
			clrsOriginalCvs.setAttribute("height", clrsCvsHeight);
			clrsSortedCvs.setAttribute("width", clrsCvsWidth);
			clrsSortedCvs.setAttribute("height", clrsCvsHeight);

			async function drawClrs(clrs) {
				clrsOriginalCtx.clearRect(0, 0, clrsCvsWidth, clrsCvsHeight);
				clrsSortedCtx.clearRect(0, 0, clrsCvsWidth, clrsCvsHeight);
				const clrWidth = clrsCvsWidth / clrs.length;

				for (let i = 0; i < clrs.length; i++) {
					const [r, g, b] = clrs[i];
					clrsOriginalCtx.fillStyle = `rgb(${r} ${g} ${b})`;
					clrsOriginalCtx.fillRect(i * clrWidth, 0, clrWidth, clrsCvsHeight);
				}

				const sorted = await h3CurveSort(clrs);
				for (let i = 0; i < sorted.length; i++) {
					const [r, g, b] = sorted[i];
					clrsSortedCtx.fillStyle = `rgb(${r} ${g} ${b})`;
					clrsSortedCtx.fillRect(i * clrWidth, 0, clrWidth, clrsCvsHeight);
				}
			}

			function drawSetClrs(_clrs) {
				const clrs = (_clrs ?? clrsInput.value)
					.trim()
					.split("\n")
					.map((value) => value.split(" ").map(Number))
					.filter((rgb) => rgb.length === 3 && rgb.every(Number.isFinite));
				if (clrs.length < 2) {
					drawSetClrs(clrsInput.getAttribute("placeholder"));
					return;
				}
				drawClrs(clrs);
			}
			clrsSet.addEventListener("click", () => drawSetClrs());

			function rdmClrs(n) {
				return [...Array(n)].map(() => [rand(0, 255), rand(0, 255), rand(0, 255)]);
			}
			clrsRdm.addEventListener("click", () => {
				let n = Number(clrsRdmN.value);
				if (!n) n = 100;
				drawClrs(rdmClrs(n));
			});

			const step = 15;
			const bits = [...Array(Math.trunc(255 / step) + 1).keys()].map((b) => step * b);
			const rgbUniform = bits.flatMap((r) => bits.flatMap((g) => bits.map((b) => [r, g, b])));
			clrsInput.setAttribute("placeholder", rgbUniform.map((rgb) => rgb.join(" ")).join("\n"));
			drawSetClrs();
		</script>
	</body>
</html>
